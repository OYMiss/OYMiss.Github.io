<!DOCTYPE html><html><head><meta charset="utf-8"><title>面向对象程序设计</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/style/style.css"></head><body>
<header class="header" id="header">
    <div class="header-wrapper">
        <div class="logo">
            <h1><a href="/">OY's Home</a></h1>
        </div>
        <nav class="main-nav">
            <ul class="menu">
                <li class="menu-item">
                    <a href="/" id="home">
                        <span class="base-name">
                            Home
                        </span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="/archives" id="archives">
                        <span class="base-name">
                            Archives
                        </span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="/categories" id="categories">
                        <span class="base-name">
                            Categories
                        </span>
                    </a>
                </li>
                <li class="menu-item">
                    <a href="/about" id="about">
                        <span class="base-name">
                            About
                        </span>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</header>
<article class="markdown-body"><h1>面向对象程序设计</h1><h3>OOP：概述</h3><p>面向对象程序设计的核心思想是：数据抽象，继承和动态绑定。</p><ul><li>通过数据抽象，将类的接口和实现进行分离</li><li>通过继承，可以定义相似的类型并对其相似关系建模</li><li>使用动态绑定，可以在一定程度上忽略相似类型的区别。</li></ul><h4>派生类构造</h4><p>注意：派生类构造函数只能初始化它的直接基类。而且必须要在初始化列表中调用基类的构造函数。</p><pre><code>struct Base {
    int i;
    Base(int i) : i(i) {}
};

struct Derived1 : public Base {
    int ii;
    Derived1(int i, int ii) :
        Base(i), ii(ii) {
    }
};

struct Derived2 : public Derived1 {
    int iii;
    Derived2(int i, int ii, int iii) :
        Derived1(i, ii), iii(iii) {
    }
};

int main() {
    Derived2 obj(1, 2, 3);
}
</code></pre><p><!--more--></p><h4>虚函数</h4><p>在C++ 中，基类必须区分两种函数：</p><ul><li>一种是基类希望派生类进行重写（override）的函数。</li><li>一种是基类希望派生类直接继承而不要改变的函数。</li></ul><p>对于希望派生类进行重写的函数，在函数定义前面加上 <code>virtual</code> 关键字。</p><p>如果基类把函数声明为，虚函数，那么该函数在派生类中<code>隐式</code> 的也是虚函数。</p><p>下面举例说明一下。</p><pre><code>#include <iostream>
using namespace std;
struct A {
    void test() {
        cout << "HelloA" << endl;
    }
};

struct B : public A {
    void test() {
        cout << "HelloB" << endl;
    }
};

struct C : public B {
    void test() {
        cout << "HelloC" << endl;
    }
};

int main() {
    A a;
    B b;
    C c;
    A *pb = &b;
    A *pc = &c;
    pb->test();
    pc->test();
}
</code></pre><p>输出结果是：</p><pre><code>HelloB
HelloC
</code></pre><p>如果把<code>virtual</code> 关键字去下来，输出的结果就是</p><pre><code>HelloA
HelloA
</code></pre><h4>动态绑定</h4><blockquote><p>只有指针或者引用 能实现运行时多态。（重点）</p></blockquote><p>可以将基类的指针或引用绑定到派生类对象上。例如：在上一节例子中，可以用 A& 指向一个 B对象。</p><pre><code>#include <iostream>
using namespace std;

struct Base {
    int v;
    virtual void print() {
        cout << "Base" << endl;
    }
};

struct Derived : public Base {
    int vv;
    void print() {
        cout << "Derived" << endl;
    }
};

void test(Base &p) {
    p.print();
}

// 对象不能实现运行时多态
void test_wrong(Base p) {
    p.print();
}

int main() {
    Derived obj;
    test(obj);
    test_wrong(obj);
}
</code></pre><p>输出结果是：</p><pre><code>Derived
Base
</code></pre><p>静态类型是变量声明时的类型（比如 p 的静态类型是 Base）。动态类型表示的是<code>内存</code>中对象的类型。（运行时才能知道）</p><p>p的动态类型根据 test 传入的参数不同，动态类型也会改变。</p><p>注意：基类指针或者引用的静态类型可能与其动态类型不同。如果既不是指针也不是引用那么动态类型永远与静态类型一致。(上述例子中的test<em>wrong 函数输出的内容)</em></p><h4>抽象基类</h4><p>在声明纯虚函数的时候在后面 书写 <code>=0</code> 就可以把虚函数定义为 纯虚。</p><p>就可以在类定义的时候，不定义这个虚函数。（让派生类去定义）。</p><p>含有纯虚函数的类是抽象基类。（<code>不能</code> 实例化抽象基类）</p><pre><code>#include <iostream>
using namespace std;

struct Base {
    int i;
    virtual void pure_virtual_fun() = 0;
};

struct Derived : public Base {
    void pure_virtual_fun() {
        cout << "HelloWorld" << endl;
    }
};

int main() {
    // 不能定义抽象基类
    // Base b; // 错误

    Derived obj;
    Base *p = &obj;
    p->pure_virtual_fun();
}
</code></pre><h3>一个应用</h3><p>下面是一个简单工厂模式。是面向对象编程中的一种重要设计模式。</p><p>有兴趣的可以把这个程序改成抽象工厂模式。</p><pre><code>#include <iostream>
using namespace std;

class Book {
protected:
    string name;
    string isbn;
public:
    virtual void show() = 0;
};

class AdventureBook : public Book {
public:
    void show() {
        cout << "this is a adventure book." << endl;
    }
};

class ScienceBook : public Book {
public:
    void show() {
        cout << "this is a science book." << endl;
    }
};

enum BookType {
    ADVENTURE,
    SCIENCE
};

class Factory {
public:
    Book * create(BookType type) {
        switch (type) {
            case BookType::ADVENTURE :
                return new AdventureBook();
            case BookType::SCIENCE :
                return new ScienceBook();
            default:
                return nullptr;
        }
    }
};

int main() {
    Factory factory;
    Book *book1 = factory.create(BookType::ADVENTURE);
    Book *book2 = factory.create(BookType::SCIENCE);

    book1->show();
    book2->show();
}

</code></pre><p>[1] Lippman S B. C++ Primer[M]. Pearson Education India, 2005.</p></article></body></html>